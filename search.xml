<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用Github和hexo轻松搭建个人博客</title>
      <link href="/2019/10/12/github+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/10/12/github+hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>Github的pages可以方便的搭建个人博客，再结合hexo静态博客框架，可以方便的构建自己的博客系统。</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><ul><li>git</li><li>hexo</li><li>node.js</li></ul><h2 id="Github-创建仓库"><a href="#Github-创建仓库" class="headerlink" title="Github 创建仓库"></a>Github 创建仓库</h2><p>创建仓库的名字必须使用 github昵称.githug.io 的格式，如 lordqiang.github.io</p><a id="more"></a><h2 id="Hexo-基本操作"><a href="#Hexo-基本操作" class="headerlink" title="Hexo 基本操作"></a>Hexo 基本操作</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="设置hexo远程仓库"><a href="#设置hexo远程仓库" class="headerlink" title="设置hexo远程仓库"></a>设置hexo远程仓库</h3><p><strong>修改</strong>config.yml，打开后滑到最后，修改成下边的样子：</p><p>deploy:<br>  type: git<br>  repository: <a href="https://github.com/xxx/xxx.github.io.git" target="_blank" rel="noopener">https://github.com/xxx/xxx.github.io.git</a><br>  branch: master</p><h3 id="安装git插件"><a href="#安装git插件" class="headerlink" title="安装git插件"></a>安装git插件</h3><p>  npm install hexo-deployer-git</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux多线程编程</title>
      <link href="/2019/10/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/10/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1线程的概念"><a href="#1线程的概念" class="headerlink" title="1线程的概念"></a>1线程的概念</h2><p>一言以蔽之，线程是cpu调度的基本单元。具体概念不在此处赘述，下面着重从程序设计的角度说明Posix pthread的基本用法。</p><h3 id="1-1线程的创建"><a href="#1-1线程的创建" class="headerlink" title="1.1线程的创建"></a>1.1线程的创建</h3><p>首先说明，在Linux编写多线程程序需要包含头文件pthread.h，编译时要连接到库libpthread，如</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc program.c -o program -lpthread</span><br></pre></td></tr></table></figure><p>线程的创建接口函数为pthread_create()，其定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span> <span class="params">(<span class="keyword">pthread_t</span> *thread,            <span class="comment">//指向线程标识符的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,       <span class="comment">//设置线程属性，不设置为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *),  <span class="comment">//线程运行函数，为一函数指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *arg)</span></span>;                       <span class="comment">//线程函数的参数</span></span><br><span class="line"><span class="comment">//    返回值：成功返回 0，失败返回错误码</span></span><br></pre></td></tr></table></figure><p>对应的线程函数可以定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">start_routine</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//your code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> tread;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">ret = pthread_create (&amp;thread, <span class="literal">NULL</span>, start_routine, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != ret) &#123;</span><br><span class="line">    errno = ret;</span><br><span class="line">    perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* a new thread is created and running start_routine concurrently ... */</span></span><br></pre></td></tr></table></figure><h3 id="1-2-线程终止"><a href="#1-2-线程终止" class="headerlink" title="1.2 线程终止"></a>1.2 线程终止</h3><p>线程的终止分两种情况，其一为某个线程的终止，其二为整个进程退出，包括其创建的所有线程。<br>整个进程退出的情况有：</p><ul><li>进程从main()函数返回。</li><li>进程中的任一线程调用exit系列函数（ exit, _Exit, or _exit）。</li><li>某个线程收到缺省动作为结束进程的信号。</li></ul><p><em>*** 要结束一个线程，不能使用exit系列函数（ exit, _Exit, or _exit），否则会使整个进程退出；同样，线程收到缺省动作为结束进程的信号也会使整个进程退出。</em></p><p>要使得单个线程退出而非整个进程，有以下三种情况：</p><ul><li>从线程函数start_routine() return 返回，返回值为线程的返回码（return code）。</li><li>被同一进程的其他线程canceled。</li><li>调用pthread_exit()退出线程。</li></ul><h4 id="1-2-1结束当前线程（terminate-yourself）"><a href="#1-2-1结束当前线程（terminate-yourself）" class="headerlink" title="1.2.1结束当前线程（terminate yourself）"></a>1.2.1结束当前线程（terminate yourself）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure><p>与进程中的exit（）类似，retval用来传递结束状态，供pthread_join()使用，详见1.3。<br>如果不关心其退出状态，可以传入NULL，用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_exit (<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h4 id="1-2-2结束其他线程（terminate-others）"><a href="#1-2-2结束其他线程（terminate-others）" class="headerlink" title="1.2.2结束其他线程（terminate others）"></a>1.2.2结束其他线程（terminate others）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span> <span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;  <span class="comment">//成功发送请求返回0，失败返回ESRCH，表示线程thread无效</span></span><br></pre></td></tr></table></figure><p>类似于进程中kill（）发送SIGKILL信号,默认状态下，pthrad_cancel()会使得指定被canceled的thread表现的如同调用了pthrad_exit(PTHREAD_CANCELED.); 然而，一个线程可以选择忽略或设置收到cancel的行为（cancellation state属性）。另外需要说明的是pthread_cancel并不会等待制定线程结束，它仅仅是发送一个请求，并立即返回。真正的退出是异步的。<br>线程可以制定退出时的操作函数（ thread cleanup handlers），可以注册多个cleanup handler，如果注册多个，执行的顺序与注册的顺序相反。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*rtn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="1-3-pthread-join（）"><a href="#1-3-pthread-join（）" class="headerlink" title="1.3 pthread_join（）"></a>1.3 pthread_join（）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span> <span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数类似于进程中的wait（）。调用pthread_join()的线程会阻塞，直到所指定的thread调用pthread_exit()退出，从start_routine返回，或者pthrad_cancel取消（即单个线程退出的三种情况）。retval用来接收退出时的返回值，同样的，如果我们不关心，则可以传入NULL。</p><p>示例用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="comment">/* join with `thread' and we don't care about its return value */</span></span><br><span class="line">ret = pthread_join (thread, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    errno = ret;</span><br><span class="line">    perror (<span class="string">"pthread_join"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程简单使用例程(保持良好的错误检查机制)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">start_thread1</span> <span class="params">(<span class="keyword">void</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%s\n"</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *) message);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">start_thread2</span> <span class="params">(<span class="keyword">void</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%s\n"</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *) message);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thing1, thing2;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message1 = <span class="string">"Thing 1"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message2 = <span class="string">"Thing 2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create two threads, each with a different message. */</span></span><br><span class="line">    ret = pthread_create (&amp;thing1, <span class="literal">NULL</span>, start_thread1, (<span class="keyword">void</span> *) message1);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread thing1 create failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create (&amp;thing2, <span class="literal">NULL</span>, start_thread2, (<span class="keyword">void</span> *) message2);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread thing2 create failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wait for the threads to exit. If we didn't join here,</span></span><br><span class="line"><span class="comment">     * we'd risk terminating this main thread before the</span></span><br><span class="line"><span class="comment">     * other two threads finished.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret = pthread_join (thing1, &amp;tret);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't join with thing1."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thing1 exit, return code(%ld)\n"</span>, (<span class="keyword">long</span>)tret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = pthread_join (thing2, &amp;tret);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't join with thing1."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thing2 exit, return code(%ld)\n"</span>, (<span class="keyword">long</span>)tret);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br><span class="line">Thing 2</span><br><span class="line">Thing 1</span><br><span class="line">thing1 <span class="built_in">exit</span>, <span class="built_in">return</span> code(1)</span><br><span class="line">thing2 <span class="built_in">exit</span>, <span class="built_in">return</span> code(2)</span><br></pre></td></tr></table></figure><h3 id="1-3-线程detach"><a href="#1-3-线程detach" class="headerlink" title="1.3 线程detach"></a>1.3 线程detach</h3><p>创建一个线程默认的状态是joinable（线程的属性后面会有详细描述）, 如果一个线程结束运行但没有被join,则它的状态类似于进程中的Zombie Process,即还有一部分资源没有被回收（退出状态码），所以创建线程者应该  pthread_join() 来等待线程运行结束，并可得到线程的退出代码，回收其资源（类似于wait,waitpid)，但是调用 pthread_join(pthread_id)后，如果该线程没有运行结束，调用者会被阻塞，在有些情况下我们并不希望如此，比如在Web服务器中当主线程为每个新来的链接创建一个子线程进行处理的时候，主线程并不希望因为调用pthread_join而阻塞（因为还要继续处理之后到来的链接），这时可以在子线程中加入代码<br>pthread_detach(pthread_self());<br>或者父线程调用<br>pthread_detach(thread_id)；<br>这将该子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源。<br>该函数接口为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="comment">//note1：我们也可以在线程创建时就设置其属性为detached，如果设置一个线程为detached，就不能再调用pthread_join来等待获取其状态，这种情况返回值是不确定的。</span></span><br><span class="line"><span class="comment">//note2： 线程与进程类似功能函数对比</span></span><br></pre></td></tr></table></figure><p>2 线程的同步和互斥<br>首先，我们来理一理互斥与同步的关系。</p><ul><li>互斥<br>互斥是指系统中的某些共享资源，一次只允许一个线程访问。当一个线程正在访问该临界资源时，其它线程必须等待。互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li><li>同步<br>同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。互斥是一种特殊的同步。</li></ul><p>实现互斥的手段有互斥锁(mutex)、读写锁(Reader_writer lock)、自旋锁(spin_lock)，实现同步需要用到条件变量（condition variable）<br>** 2.1 互斥锁（Mutex）**<br>通过锁机制实现线程间的互斥，保护临界资源。主要有以下接口函数：<br>初始化锁—在Linux下，线程的互斥量数据类型是pthread_mutex_t。在使用前,要对它进行初始化。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态分配：</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">//动态分配：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutex_attr_t</span> *mutexattr)</span></span>;</span><br></pre></td></tr></table></figure><p>加锁—对共享资源的访问，要对互斥量进行加锁，如果互斥量已经上了锁，调用线程会阻塞，直到互斥量被解锁。<br>如果不希望阻塞，可以使用pthread_mutex_trylock()，如果不能获得锁，立即返回EBUSY，二不会阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(pthread_mutex *mutex)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>解锁—在完成了对共享资源的访问后，要对互斥量进行解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>销毁锁锁在是使用完成后，需要进行销毁以释放资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>注意：要避免潜在的死锁危险，有多个互斥锁的情况下，各个线程加锁的顺序要相同。<br>例程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadA</span><span class="params">(<span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lock);          <span class="comment">//锁</span></span><br><span class="line">    a -= <span class="number">50</span>;</span><br><span class="line">    sleep(<span class="number">5</span>);                                      <span class="comment">//执行到一半 使用sleep 放弃cpu调度</span></span><br><span class="line">    b += <span class="number">50</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadB</span><span class="params">(<span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);                            <span class="comment">//放弃CPU调度 目的先让A线程运行。</span></span><br><span class="line">    pthread_mutex_lock(&amp;lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">    pthread_mutex_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tida, tidb;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tida, <span class="literal">NULL</span>, ThreadA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tidb, <span class="literal">NULL</span>, ThreadB, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(tida, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tidb, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上输出为300  去掉锁操作  输出为250。此例程为了说明互斥锁功能，正常使用试临界资源中不宜采用sleep这样的操作。<br>** 2.2 读写锁 **<br>读写锁跟互斥锁类似，只是在并发性上更加精细。互斥锁的状态要么加锁，要么未加锁，同一时刻只有一个线程可以获得锁。<br>读写锁有三种状态：</p><ul><li>读加锁状态</li><li>写加锁状态</li><li>未加锁状态<br>如果一个读写锁在写加锁状态，所有试图加锁的线程在该读写锁释放前都会block。如果在读加锁状态，那么所有试图以读模式加锁的线程都将成功，但是如果要以写模式加锁，必须等到所有的加锁线程释放锁，这种情况下，以读模式加锁的线程也将阻塞。<br>读写锁适合在经常读而不经常写的场景下使用。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> tsptr)</span></span>;        </span><br><span class="line"><span class="comment">//BOTH: return 0 if OK, error number on failure</span></span><br></pre></td></tr></table></figure></li></ul><p>** 2.3 自旋锁（spin lock）**<br>关于自旋锁，APUE中的介绍感觉很到位，就不翻译了：</p><blockquote><p>A spin lock is like a mutex, except that instead of blocking a process by sleeping, the process is blocked by busy-waiting (spinning) until the lock can be acquired.  A spin lock  could  be  used  in  situations  where locks  are held  for  short  periods  of  times  and threads don’t want to incur the cost of being descheduled.<br>鉴于spin lock忙等的特性，spin lock用于底层实时要求高的场景，且所锁定的临界区域尽量小，持锁时间尽量小。用户态，除非是早非抢占式实时操作系统上，否则没有使用的必要。<br>spin lock的使用方式跟mutex类似，此处不再举例。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock, <span class="keyword">int</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br></pre></td></tr></table></figure><p>Caution： We  need  to  be  careful  not  to  call  any  functions  that  might  sleep while holding the spin lock. If we do, then we’ll waste CPU resources by extending the time other threads will spin if they try to acquire it.<br>** 2.4 条件变量（cond）**<br>与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。条件变量分为两部分: 条件和变量。条件本身是由互斥量保护的。线程在改变条件状态前先要锁住互斥量。条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。条件的检测是在互斥锁的保护下进行的。如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的互斥锁。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得互斥锁，重新评价条件。如果两进程共享可读写的内存，条件变量可以被用来实现这两进程间的线程同步。<br>初始化条件变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态态初始化，</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIER;</span><br><span class="line"><span class="comment">//动态初始化，</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_condattr_t</span> *cond_attr)</span></span>;</span><br><span class="line">等待条件成立：释放锁,同时阻塞等待条件变量为真才行。timewait()设置等待时间,仍未signal,返回ETIMEOUT(加锁保证只有一个线程wait)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timewait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond,pthread_mutex *mutex,<span class="keyword">const</span> timespec *abstime)</span></span>;</span><br><span class="line">激活条件变量：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>; <span class="comment">//解除所有线程的阻塞</span></span><br><span class="line">清除条件变量：无线程等待,否则返回EBUSY</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><p>应用示例：<br>caution：在thread_cond_wait()之前,必须先lock相关联的mutex, 因为假如目标条件未满足,pthread_cond_wait()实际上会unlock该mutex, 然后block,在目标条件满足后再重新lock该mutex, 然后返回.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">m_next</span>;</span></span><br><span class="line"><span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">workq</span>;</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> qready = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> qlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_msg</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先要加锁，因为 pthread_cond_wait（）内部，如果条件不满足，则会释放锁，然后block</span></span><br><span class="line">        pthread_mutex_lock(&amp;qlock);</span><br><span class="line">        <span class="keyword">while</span> (workq == <span class="literal">NULL</span>)</span><br><span class="line">        pthread_cond_wait(&amp;qready, &amp;qlock);</span><br><span class="line">        mp = workq;</span><br><span class="line">        workq = mp-&gt;m_next;</span><br><span class="line">        pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">        <span class="comment">/* now process the message mp */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue_msg</span><span class="params">(struct msg *mp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;qlock);</span><br><span class="line">    mp-&gt;m_next = workq;</span><br><span class="line">    workq = mp;</span><br><span class="line">    pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">    pthread_cond_signal(&amp;qready);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习题：<br>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><ul><li>多线程联系： 编写一个程序，开启3个线程，这3个线程的ID分别为Ａ、Ｂ、Ｃ，</li><li>每个线程将自己的ID在屏幕上打印10遍，要求输出结果必须按ABC的顺序显示；如：</li><li>ABCABC…依次递推*</li><li><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond_a2b = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond_b2c = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond_c2a = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> flag_lock  = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tida_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;flag_lock);</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(flag != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait( &amp;cond_c2a, &amp;flag_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        flag += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a"</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;flag_lock);</span><br><span class="line">        pthread_cond_signal(&amp;cond_a2b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tidb_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;flag_lock);</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(flag != <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond_a2b, &amp;flag_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        flag += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"b"</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;flag_lock);</span><br><span class="line">        pthread_cond_signal(&amp;cond_b2c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> iret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pthread_t</span> tida,tidb;</span><br><span class="line"></span><br><span class="line">    iret = pthread_create(&amp;tida, <span class="literal">NULL</span>, tida_func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>( iret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iret = pthread_create(&amp;tidb, <span class="literal">NULL</span>, tidb_func, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">if</span>(iret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(count &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;flag_lock);     </span><br><span class="line">        <span class="keyword">while</span>(flag != <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond_b2c,&amp;flag_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"c "</span>);</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">        pthread_mutex_unlock(&amp;flag_lock);</span><br><span class="line">        pthread_cond_signal(&amp;cond_c2a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-信号量-sem"><a href="#2-3-信号量-sem" class="headerlink" title="2.3 信号量(sem)"></a>2.3 信号量(sem)</h3><p>如同进程一样，线程也可以通过信号量来实现通信，虽然是轻量级的。信号量函数的名字都以”sem_”打头。线程使用的基本信号量函数有四个。<br>信号量初始化：<br>    int sem_init (sem_t *sem , int pshared, unsigned int value);<br>这是对由sem指定的信号量进行初始化，设置好它的共享选项(linux 只支持为0，即表示它是当前进程的局部信号量)，然后给它一个初始值VALUE。<br>等待信号量：给信号量减1，然后等待直到信号量的值大于0。<br>    int sem_wait(sem_t *sem);<br>释放信号量：信号量值加1。并通知其他等待线程。<br>    int sem_post(sem_t *sem);<br>销毁信号量：我们用完信号量后都它进行清理。归还占有的一切资源。<br>    int sem_destroy(sem_t *sem);</p><p>单纯互斥：用互斥锁<br>既要同步又要互斥：条件变量和互斥所结合使用</p><p>note<br>单纯同步：用信号量</p><h2 id="3-线程相关的属性"><a href="#3-线程相关的属性" class="headerlink" title="3 线程相关的属性"></a>3 线程相关的属性</h2><p>3.1 线程的属性</p><p>在前面的例程中，我们在创建线程时，线程属性参数都传入了NULL，取了默认的属性。线程的属性由 pthread_attr_t 结构定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程属性结构如下：  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span>                   detachstate;      <span class="comment">//线程的分离状态  </span></span><br><span class="line">    <span class="keyword">int</span>                   schedpolicy;     <span class="comment">//线程调度策略  </span></span><br><span class="line">    structsched_param     schedparam;      <span class="comment">//线程的调度参数  </span></span><br><span class="line">    <span class="keyword">int</span>                   inheritsched;    <span class="comment">//线程的继承性  </span></span><br><span class="line">    <span class="keyword">int</span>                   scope;           <span class="comment">//线程的作用域  </span></span><br><span class="line">    <span class="keyword">size_t</span>                guardsize;       <span class="comment">//线程栈末尾的警戒缓冲区大小  </span></span><br><span class="line">    <span class="keyword">int</span>                   stackaddr_set;   <span class="comment">//线程的栈设置  </span></span><br><span class="line">    <span class="keyword">void</span>*                 stackaddr;       <span class="comment">//线程栈的位置  </span></span><br><span class="line">    <span class="keyword">size_t</span>                stacksize;       <span class="comment">//线程栈的大小  </span></span><br><span class="line">&#125;<span class="keyword">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure><p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。之后须用pthread_attr_destroy函数来释放资源。线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省1M的堆栈、与父进程同样级别的优先级。</p><p>每个属性都有其函数接口设置或获取，在此不一一列举，下面示例为创建一个detached 线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">makethread</span><span class="params">(<span class="keyword">void</span> *(*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  err;</span><br><span class="line">    <span class="keyword">pthread_t</span>  tid;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span>  attr;</span><br><span class="line">    err = pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>(err);</span><br><span class="line">    err = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">        err = pthread_create(&amp;tid, &amp;attr, fn, arg);</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">return</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.2 互斥锁属性、读写锁属性、条件变量属性</p><p>互斥所属性：<br>process-shared attribute<br>robust attribute<br>type attribute<br>读写锁属性<br>process-shared attribute<br>条件变量属性：<br>process-shared attribute<br>clock attribute</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu18.04国内软件源</title>
      <link href="/2019/10/12/ubuntu18-04%E5%9B%BD%E5%86%85%E8%BD%AF%E4%BB%B6%E6%BA%90/"/>
      <url>/2019/10/12/ubuntu18-04%E5%9B%BD%E5%86%85%E8%BD%AF%E4%BB%B6%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>ubuntu默认的软件源是国外的，下载软件很慢，需要更新为国内的源以提升速度，现在可以通过ubunt software来设置了，不过还是习惯了命令行修改的方式。</p><h2 id="更新方法"><a href="#更新方法" class="headerlink" title="更新方法"></a>更新方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/apt/sources.list</span><br><span class="line"><span class="comment">#替换内容为国内源码</span></span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="国内源"><a href="#国内源" class="headerlink" title="国内源"></a>国内源</h2><p>国内有很多Ubuntu的镜像源,如下</p><p>中科大源</p><p>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="https://mirrors.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="https://mirrors.ustc.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse</p><p>阿里源</p><p>deb <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a> bionic-backports main restricted universe multiverse</p><p>163源</p><p>deb <a href="http://mirrors.163.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.163.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.163.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.163.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.163.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb <a href="http://mirrors.163.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.163.com/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.163.com/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.163.com/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.163.com/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.163.com/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="http://mirrors.163.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.163.com/ubuntu/</a> bionic-backports main restricted universe multiverse</p><p>清华源</p><p>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse<br>deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-proposed main restricted universe multiverse</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PDF-XChange Viewer 设置背景颜色</title>
      <link href="/2019/10/12/PDF-XChange-Viewer-%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2/"/>
      <url>/2019/10/12/PDF-XChange-Viewer-%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p>日常阅读Pdf文档书籍比较多，白色的背景会比较刺眼，传言淡绿色的会比较护眼（真假不知）。<br>PDF-XChange Viewer 这款软件在阅读pdf时体验非常好，打开大文件相应也很快，具有完善的注释功能。本人在设置背景颜色时颇为曲折，书签栏的背景颜色始终难以设置成功，经过多次实验发现了最方便的设置如下位置：<br>编辑  -&gt;  参数设置 -&gt; 自定义UI -&gt; 颜色</p><a id="more"></a><p><img src="1.jpg" alt="设置效果"></p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下 Samba 服务器配置samb目录为用户的home目录</title>
      <link href="/2019/10/10/samba%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/10/10/samba%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>在多用户的使用场景下，为了统一为各个用户配置samba目录，可以将用户的home目录统一配置成samba目录，<br>下面以在ubuntu上配置为例进行说明。</p><h2 id="1-先要安装Samba"><a href="#1-先要安装Samba" class="headerlink" title="1.先要安装Samba"></a>1.先要安装Samba</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install samba openssh-server</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-编译Samba配置文件"><a href="#2-编译Samba配置文件" class="headerlink" title="2.编译Samba配置文件"></a>2.编译Samba配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/samba/smb.conf</span><br></pre></td></tr></table></figure><p>找到[homes]项，此项默认是注释掉的，取消其注释，然后修改其具体内容，修改成如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[homes]</span><br><span class="line">   comment = Home Directories</span><br><span class="line">   browseable = yes</span><br><span class="line"><span class="comment"># By default, the home directories are exported read-only. Change the</span></span><br><span class="line"><span class="comment"># next parameter to 'no' if you want to be able to write to them.</span></span><br><span class="line">   <span class="built_in">read</span> only = no</span><br><span class="line"><span class="comment"># File creation mask is set to 0700 for security reasons. If you want to</span></span><br><span class="line"><span class="comment"># create files with group=rw permissions, set next parameter to 0775.</span></span><br><span class="line">   create mask = 0755 <span class="comment">#建议将权限修改成0755，这样其它用户只是不能修改</span></span><br><span class="line"><span class="comment"># Directory creation mask is set to 0700 for security reasons. If you want to</span></span><br><span class="line"><span class="comment"># create dirs. with group=rw permissions, set next parameter to 0775.</span></span><br><span class="line">   directory mask = 0755</span><br><span class="line"><span class="comment"># By default, \\server\username shares can be connected to by anyone</span></span><br><span class="line"><span class="comment"># with access to the samba server. Un-comment the following parameter</span></span><br><span class="line"><span class="comment"># to make sure that only "username" can connect to \\server\username</span></span><br><span class="line"><span class="comment"># The following parameter makes sure that only "username" can connect</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This might need tweaking when using external authentication schemes</span></span><br><span class="line">   valid users = %S <span class="comment">#本行需要取消注释</span></span><br></pre></td></tr></table></figure><p>如上修改完成后wq保存退出！</p><h2 id="3-重启samba服务："><a href="#3-重启samba服务：" class="headerlink" title="3. 重启samba服务："></a>3. 重启samba服务：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service smbd restart</span><br><span class="line">sudo service nmbd restart</span><br></pre></td></tr></table></figure><h2 id="4-增加一个现有用户的对应samba帐号："><a href="#4-增加一个现有用户的对应samba帐号：" class="headerlink" title="4. 增加一个现有用户的对应samba帐号："></a>4. 增加一个现有用户的对应samba帐号：</h2><p>如我已经有一个用户叫dante，现在给dante开通samba帐号(必须设置)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo smbpasswd -a dante</span><br></pre></td></tr></table></figure><p>根据提示输入两次密码即可。</p><h2 id="5-现在可以测试了，在Window下按win-r，输入samba地址尝试登录："><a href="#5-现在可以测试了，在Window下按win-r，输入samba地址尝试登录：" class="headerlink" title="5.现在可以测试了，在Window下按win+r，输入samba地址尝试登录："></a>5.现在可以测试了，在Window下按win+r，输入samba地址尝试登录：</h2><p>\10.0.0.2\dante</p><h2 id="6-此时windows应该会弹出窗口要求输入用户名和密码了，输入吧。Enjoy！"><a href="#6-此时windows应该会弹出窗口要求输入用户名和密码了，输入吧。Enjoy！" class="headerlink" title="6.此时windows应该会弹出窗口要求输入用户名和密码了，输入吧。Enjoy！"></a>6.此时windows应该会弹出窗口要求输入用户名和密码了，输入吧。Enjoy！</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> samba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git设置ssh-key免输密码</title>
      <link href="/2019/10/10/git%E8%AE%BE%E7%BD%AEssh-key%E5%85%8D%E8%BE%93%E5%AF%86%E7%A0%81/"/>
      <url>/2019/10/10/git%E8%AE%BE%E7%BD%AEssh-key%E5%85%8D%E8%BE%93%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>当我们从github或者gitlab上clone项目或者参与项目时，我们需要证明我们的身份。一种可能的解决方法是我们在每次访问的时候都带上账户名、密码,另外一种办法是在本地保存一个唯一key，在你的账户中也保存一份该key，在你访问时带上你的key即可。github、gitlab就是采用key来验证你的身份的，并且利用RSA算法来生成这个密钥。</p><a id="more"></a><p>1.生成SSH密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"mail@gmail.com"</span></span><br></pre></td></tr></table></figure><p>执行后，<br>第一个提示输入保存文件名，默认为空，回车。</p><p>第二个提示输入密钥，默认为空，回车</p><p>第三个确认刚输入密钥，默认为空，回车</p><p>完成后，默认保存在当前 用户的home目录下 </p><p>~/.ssh/id_rsa 和id_rsa.pub</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh     <span class="comment">#可以看到生成的文件</span></span><br></pre></td></tr></table></figure><p>2.设置密钥（gitlab/gitblit都有试过，其他未测）</p><p>在 Gitblit 管理页面，把 id_rsa.pub 中的内容复制到 SSH Keys，保存确定。</p><p>3.clone 克隆 （或其他操作）</p><p>设置成功，git clone/push/pull无须再输入密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> ssh://<span class="built_in">test</span>@192.168.0.254:29418/test.git</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 常用命令一览</title>
      <link href="/2019/10/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/"/>
      <url>/2019/10/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h2 id="git配置（config）："><a href="#git配置（config）：" class="headerlink" title="git配置（config）："></a>git配置（config）：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git version                                                 <span class="comment"># 查看版本</span></span><br><span class="line">git config -l                                               <span class="comment"># 查看当前配置</span></span><br><span class="line">git config --global user.name <span class="string">"Dean"</span>                        <span class="comment"># 设置用户名，邮箱  </span></span><br><span class="line">git config --global user.email g.xiangyu1990@gmail.com      <span class="comment"># 设置用户名，邮箱  </span></span><br><span class="line">git config --global alias.ci commit                         <span class="comment"># 设置git命令的别名</span></span><br><span class="line">git config --global alias.co checkout                       <span class="comment"># 设置git命令的别名</span></span><br><span class="line">git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br><span class="line">git config --global core.editor vim                         <span class="comment">#设置编辑器为vim</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="git仓库（repository）："><a href="#git仓库（repository）：" class="headerlink" title="git仓库（repository）："></a>git仓库（repository）：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个本地的git仓库并命名：  </span></span><br><span class="line">git init demo</span><br><span class="line">​</span><br><span class="line"><span class="comment"># 克隆一个远程的git仓库到指定路径：  </span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/a396901990/android.git /path/workpsace</span><br></pre></td></tr></table></figure><h2 id="git分支（branch）"><a href="#git分支（branch）" class="headerlink" title="git分支（branch）:"></a>git分支（branch）:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch                      <span class="comment"># 查看分支</span></span><br><span class="line">git remote show origin          <span class="comment"># 查看所有分支</span></span><br><span class="line">git branch &lt;branchname&gt;         <span class="comment"># 创建新分支</span></span><br><span class="line">git checkout &lt;branchname&gt;       <span class="comment"># 切换到分支</span></span><br><span class="line">git checkout -b &lt;new_branch&gt;    <span class="comment"># 创建并切换到新分支</span></span><br><span class="line">git branch -d &lt;branchname&gt;      <span class="comment"># 删除分支（-D强删） </span></span><br><span class="line">git branch -m &lt;old&gt; &lt;new&gt;       <span class="comment"># 本地分支重命名</span></span><br></pre></td></tr></table></figure><h2 id="git添加（add）："><a href="#git添加（add）：" class="headerlink" title="git添加（add）："></a>git添加（add）：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;      <span class="comment"># 将本地指定文件名或目录（新增和修改，没有删除）的文件添加到暂存区</span></span><br><span class="line">git add .           <span class="comment"># 将本地所有的（新增和修改，没有删除）文件添加到暂存区</span></span><br><span class="line">git add -u          <span class="comment"># 将本地的（修改和删除，没有新增）文件添加到暂存区</span></span><br><span class="line">git add -A          <span class="comment"># 将本地所有改动添加到暂存区（git add -A = git add . + git add -u）</span></span><br><span class="line">git add -i          <span class="comment"># 打开一个交互式界面按需求添加文件</span></span><br></pre></td></tr></table></figure><h2 id="git删除-重命名（rm-mv）："><a href="#git删除-重命名（rm-mv）：" class="headerlink" title="git删除/重命名（rm/mv）："></a>git删除/重命名（rm/mv）：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt;                   <span class="comment"># 删除文件</span></span><br><span class="line">git rm -r &lt;floder&gt;              <span class="comment"># 删除文件夹</span></span><br><span class="line">git rm --cached &lt;file&gt;          <span class="comment"># 从版本库中删除文件，但不删除文件      </span></span><br><span class="line">git mv &lt;old_name&gt; &lt;new_name&gt;    <span class="comment"># 文件重命名</span></span><br></pre></td></tr></table></figure><h2 id="git提交（commit）："><a href="#git提交（commit）：" class="headerlink" title="git提交（commit）："></a>git提交（commit）：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit  -m <span class="string">"comment"</span>           <span class="comment"># 提交暂存区中的内容（已经add）并添加注释</span></span><br><span class="line">git commit -a                      <span class="comment"># 把修改的文件添加到暂存区（不包括新建(untracked)的文件），然后提交。</span></span><br><span class="line">git commit --amend                 <span class="comment"># 修改提交的commit（没有push）</span></span><br><span class="line">git commit --amend -m <span class="string">"comment"</span>    <span class="comment"># 修改commit注解</span></span><br></pre></td></tr></table></figure><h2 id="git差异（diff）："><a href="#git差异（diff）：" class="headerlink" title="git差异（diff）："></a>git差异（diff）：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git diff                     <span class="comment"># 查看工作目录（working tree）暂存区（index）的差别</span></span><br><span class="line">git diff --cached            <span class="comment"># 查看暂存起来的文件（stage）与并未提交（commit）的差别</span></span><br><span class="line">git diff --staged            <span class="comment"># 同上</span></span><br><span class="line">git diff HEAD                <span class="comment"># 查看最后一次提交之后的的差别（HEAD代表最近一次commit的信息）</span></span><br><span class="line">git diff --<span class="built_in">stat</span>              <span class="comment"># 查看显示简略结果(文件列表)</span></span><br><span class="line">git diff commit1 commit2     <span class="comment"># 对比两次提交的内容（也可以是branch，哈希值）</span></span><br></pre></td></tr></table></figure><h2 id="git查看历史（log）："><a href="#git查看历史（log）：" class="headerlink" title="git查看历史（log）："></a>git查看历史（log）：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">git <span class="built_in">log</span> -3           <span class="comment"># 查看前3次修改</span></span><br><span class="line">git <span class="built_in">log</span> --oneline    <span class="comment"># 一行显示一条log</span></span><br><span class="line">git <span class="built_in">log</span> -p           <span class="comment"># 查看详细修改内容  </span></span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span>       <span class="comment"># 查看提交统计信息</span></span><br><span class="line">git <span class="built_in">log</span> --graph      <span class="comment"># 显示何时出现了分支和合并等信息</span></span><br></pre></td></tr></table></figure><h2 id="git查看状态（status）："><a href="#git查看状态（status）：" class="headerlink" title="git查看状态（status）："></a>git查看状态（status）：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status              <span class="comment"># 查看你的代码在缓存与当前工作目录的状态</span></span><br><span class="line">git status -s           <span class="comment"># 将结果以简短的形式输出</span></span><br><span class="line">git status --ignored    <span class="comment"># 显示被忽略的文件</span></span><br></pre></td></tr></table></figure><h2 id="git存储（stash）"><a href="#git存储（stash）" class="headerlink" title="git存储（stash）:"></a>git存储（stash）:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git stash                   <span class="comment"># 保存当前的工作进度</span></span><br><span class="line">git stash save <span class="string">"message"</span>    <span class="comment"># 保存进度加说明</span></span><br><span class="line">git stash list              <span class="comment"># 显示进度列表</span></span><br><span class="line">git stash pop               <span class="comment"># 恢复最新保存的工作进度，并将恢复的工作进度从存储的列表中删除</span></span><br><span class="line">git stash apply             <span class="comment"># 恢复最新保存工作进度，但不删除</span></span><br><span class="line">git stash drop              <span class="comment"># 删除一个进度，默认删除最新的</span></span><br><span class="line">git stash clear             <span class="comment"># 删除所有</span></span><br></pre></td></tr></table></figure><h2 id="git重置（reset）"><a href="#git重置（reset）" class="headerlink" title="git重置（reset）:"></a>git重置（reset）:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed           <span class="comment"># 同不带任何参数的git reset一样，重置暂存区，但不改变工作区</span></span><br><span class="line">git reset --soft            <span class="comment"># 回退到某个版本，不改变暂存区和工作区（如果还要提交，直接commit即可）</span></span><br><span class="line">git reset --hard            <span class="comment"># 彻底回退到某个版本，替换暂存区和工作区，本地的源码也会变为上一个版本的内容</span></span><br><span class="line">git reset                   <span class="comment"># 将之前用git add命令添加到暂存区的内容撤出暂存区（相当于git add -A 的反向操作）</span></span><br><span class="line">git reset HEAD              <span class="comment"># HEAD 效果同上，因为引用重置到HEAD相当与没有重置</span></span><br><span class="line">git reset filename          <span class="comment"># 将文件撤出暂存区（相当于git add filename的反向操作）</span></span><br><span class="line">git reset HEAD^             <span class="comment"># 引用回退一次（工作区不变，暂存区回退）</span></span><br><span class="line">git reset --soft HEAD~3     <span class="comment"># 引用回退三次（工作区不变，暂存区不变）</span></span><br></pre></td></tr></table></figure><h2 id="git撤销（revert）："><a href="#git撤销（revert）：" class="headerlink" title="git撤销（revert）："></a>git撤销（revert）：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git revert commit               <span class="comment"># 撤销指定commit</span></span><br><span class="line">git revert HEAD                 <span class="comment"># 撤销上一次commit</span></span><br><span class="line">git revert -no-edit HEAD        <span class="comment"># 撤销上一次并直接使用默认注释</span></span><br><span class="line">git revert -n HEAD              <span class="comment"># 撤销上一次但不commit</span></span><br></pre></td></tr></table></figure><h2 id="git合并（merge）："><a href="#git合并（merge）：" class="headerlink" title="git合并（merge）："></a>git合并（merge）：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch_name&gt;             <span class="comment"># 合并</span></span><br><span class="line">git merge --no-ff &lt;branch_name&gt;     <span class="comment"># 采用no fast forward的合并方式，这种方式在合并的同时会生成一个新的commit</span></span><br><span class="line">git merge --abort                   <span class="comment"># 尽量回退到merge前的状态（可能会失败）</span></span><br></pre></td></tr></table></figure><h2 id="git重新基变（rebase）："><a href="#git重新基变（rebase）：" class="headerlink" title="git重新基变（rebase）："></a>git重新基变（rebase）：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;branch_name&gt;    <span class="comment"># </span></span><br><span class="line">git rebase --<span class="built_in">continue</span>       <span class="comment"># 执行rebase出现冲突解决后，执行该命令会继续应用(apply)余下的补丁</span></span><br><span class="line">git rebase --skip           <span class="comment"># 跳过当前提交</span></span><br><span class="line">git rebase --abort          <span class="comment"># 终止rebase, 分支会回到rebase开始前的状态</span></span><br></pre></td></tr></table></figure><h2 id="git获取-拉（fetch-pull）："><a href="#git获取-拉（fetch-pull）：" class="headerlink" title="git获取/拉（fetch/pull）："></a>git获取/拉（fetch/pull）：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch               <span class="comment"># 从远程获取最新版本到本地，不会自动merge</span></span><br><span class="line">git pull                <span class="comment"># 从远程获取最新版本并merge到本地</span></span><br><span class="line">git pull --rebase       <span class="comment"># 暂存本地变更，合并远程最新改动，合并刚刚暂存的本地变更（不产生无用的merge的同步）</span></span><br></pre></td></tr></table></figure><h2 id="git推（push）"><a href="#git推（push）" class="headerlink" title="git推（push）:"></a>git推（push）:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git push origin master      <span class="comment"># 将本地分支推送到origin主机的master分支</span></span><br><span class="line">git push -u origin master   <span class="comment"># -u指定origin为默认主机，后面就可以不加任何参数使用git push了</span></span><br><span class="line">git push -f origin          <span class="comment"># -f强推，在远程主机产生一个"非直进式"的合并(non-fast-forward merge)</span></span><br><span class="line">git push --all origin       <span class="comment"># 将所有本地分支都推送到origin主</span></span><br><span class="line">git push origin &lt;本地分支&gt;：&lt;远程分支&gt; <span class="comment">#个人目前常用</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
