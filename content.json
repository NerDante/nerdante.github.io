{"meta":{"title":"强大人的小屋","subtitle":"随风而动，随性而为","description":null,"author":"强大人","url":"http://yoursite.com","root":"/"},"pages":[{"title":"文章分类","date":"2019-10-10T08:04:34.000Z","updated":"2019-10-10T13:44:10.404Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-10T08:37:05.000Z","updated":"2019-10-10T13:44:10.404Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"半路出家的码农一枚！！"},{"title":"标签","date":"2019-10-10T08:13:25.000Z","updated":"2019-10-10T13:44:10.404Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用Github和hexo轻松搭建个人博客","slug":"github+hexo搭建个人博客","date":"2019-10-12T14:57:57.608Z","updated":"2019-10-12T14:57:57.609Z","comments":true,"path":"2019/10/12/github+hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2019/10/12/github+hexo搭建个人博客/","excerpt":"Github的pages可以方便的搭建个人博客，再结合hexo静态博客框架，可以方便的构建自己的博客系统。安装依赖 git hexo node.js Github 创建仓库创建仓库的名字必须使用 github昵称.githug.io 的格式，如 lordqiang.github.io","text":"Github的pages可以方便的搭建个人博客，再结合hexo静态博客框架，可以方便的构建自己的博客系统。安装依赖 git hexo node.js Github 创建仓库创建仓库的名字必须使用 github昵称.githug.io 的格式，如 lordqiang.github.io Hexo 基本操作Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 设置hexo远程仓库修改config.yml，打开后滑到最后，修改成下边的样子： deploy: type: git repository: https://github.com/xxx/xxx.github.io.git branch: master 安装git插件 npm install hexo-deployer-git","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"linux多线程编程","slug":"linux多线程编程","date":"2019-10-12T10:01:37.000Z","updated":"2019-10-13T02:03:09.452Z","comments":true,"path":"2019/10/12/linux多线程编程/","link":"","permalink":"http://yoursite.com/2019/10/12/linux多线程编程/","excerpt":"1线程的概念一言以蔽之，线程是cpu调度的基本单元。具体概念不在此处赘述，下面着重从程序设计的角度说明Posix pthread的基本用法。1.1线程的创建首先说明，在Linux编写多线程程序需要包含头文件pthread.h，编译时要连接到库libpthread，如","text":"1线程的概念一言以蔽之，线程是cpu调度的基本单元。具体概念不在此处赘述，下面着重从程序设计的角度说明Posix pthread的基本用法。1.1线程的创建首先说明，在Linux编写多线程程序需要包含头文件pthread.h，编译时要连接到库libpthread，如 1gcc program.c -o program -lpthread 线程的创建接口函数为pthread_create()，其定义为： 123456#include &lt;pthread.h&gt;int pthread_create (pthread_t *thread, //指向线程标识符的指针 const pthread_attr_t *attr, //设置线程属性，不设置为NULL void *(*start_routine) (void *), //线程运行函数，为一函数指针 void *arg); //线程函数的参数// 返回值：成功返回 0，失败返回错误码 对应的线程函数可以定义为： 1234void * start_routine(void *arg)&#123; //your code&#125; 用法示例: 123456789pthread_t tread;int ret;ret = pthread_create (&amp;thread, NULL, start_routine, NULL);if (0 != ret) &#123; errno = ret; perror(\"pthread_create\"); return -1;&#125;/* a new thread is created and running start_routine concurrently ... */ 1.2 线程终止线程的终止分两种情况，其一为某个线程的终止，其二为整个进程退出，包括其创建的所有线程。整个进程退出的情况有： 进程从main()函数返回。 进程中的任一线程调用exit系列函数（ exit, _Exit, or _exit）。 某个线程收到缺省动作为结束进程的信号。 *** 要结束一个线程，不能使用exit系列函数（ exit, _Exit, or _exit），否则会使整个进程退出；同样，线程收到缺省动作为结束进程的信号也会使整个进程退出。 要使得单个线程退出而非整个进程，有以下三种情况： 从线程函数start_routine() return 返回，返回值为线程的返回码（return code）。 被同一进程的其他线程canceled。 调用pthread_exit()退出线程。 1.2.1结束当前线程（terminate yourself）12#include &lt;pthread.h&gt;void pthread_exit(void *retval); 与进程中的exit（）类似，retval用来传递结束状态，供pthread_join()使用，详见1.3。如果不关心其退出状态，可以传入NULL，用法： 1pthread_exit (NULL); 1.2.2结束其他线程（terminate others）12#include &lt;pthread.h&gt;int pthread_cancel (pthread_t thread); //成功发送请求返回0，失败返回ESRCH，表示线程thread无效 类似于进程中kill（）发送SIGKILL信号,默认状态下，pthrad_cancel()会使得指定被canceled的thread表现的如同调用了pthrad_exit(PTHREAD_CANCELED.); 然而，一个线程可以选择忽略或设置收到cancel的行为（cancellation state属性）。另外需要说明的是pthread_cancel并不会等待制定线程结束，它仅仅是发送一个请求，并立即返回。真正的退出是异步的。线程可以制定退出时的操作函数（ thread cleanup handlers），可以注册多个cleanup handler，如果注册多个，执行的顺序与注册的顺序相反。 123#include &lt;pthread.h&gt;void pthread_cleanup_push(void (*rtn)(void *), void *arg);void pthread_cleanup_pop(int execute); 1.3 pthread_join（）12#include &lt;pthread.h&gt;int pthread_join (pthread_t thread, void **retval); 该函数类似于进程中的wait（）。调用pthread_join()的线程会阻塞，直到所指定的thread调用pthread_exit()退出，从start_routine返回，或者pthrad_cancel取消（即单个线程退出的三种情况）。retval用来接收退出时的返回值，同样的，如果我们不关心，则可以传入NULL。 示例用法： 12345678int ret;/* join with `thread' and we don't care about its return value */ret = pthread_join (thread, NULL);if (ret) &#123; errno = ret; perror (\"pthread_join\"); return -1;&#125; 线程简单使用例程(保持良好的错误检查机制) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;void * start_thread1 (void *message)&#123; printf (\"%s\\n\", (const char *) message); pthread_exit((void *)1);&#125;void * start_thread2 (void *message)&#123; printf (\"%s\\n\", (const char *) message); pthread_exit((void *)2);&#125;int main (void)&#123; pthread_t thing1, thing2; int ret; void *tret; const char *message1 = \"Thing 1\"; const char *message2 = \"Thing 2\"; /* Create two threads, each with a different message. */ ret = pthread_create (&amp;thing1, NULL, start_thread1, (void *) message1); if(0 != ret) &#123; printf(\"thread thing1 create failed\"); return -1; &#125; ret = pthread_create (&amp;thing2, NULL, start_thread2, (void *) message2); if(0 != ret) &#123; printf(\"thread thing2 create failed\"); return -1; &#125; /* * Wait for the threads to exit. If we didn't join here, * we'd risk terminating this main thread before the * other two threads finished. */ ret = pthread_join (thing1, &amp;tret); if(0 != ret) &#123; printf(\"can't join with thing1.\"); return -1; &#125; else &#123; printf(\"thing1 exit, return code(%ld)\\n\", (long)tret); &#125; ret = pthread_join (thing2, &amp;tret); if(0 != ret) &#123; printf(\"can't join with thing1.\"); return -1; &#125; else &#123; printf(\"thing2 exit, return code(%ld)\\n\", (long)tret); &#125; return 0;&#125; 执行结果： 12345./a.outThing 2Thing 1thing1 exit, return code(1)thing2 exit, return code(2) 1.3 线程detach创建一个线程默认的状态是joinable（线程的属性后面会有详细描述）, 如果一个线程结束运行但没有被join,则它的状态类似于进程中的Zombie Process,即还有一部分资源没有被回收（退出状态码），所以创建线程者应该 pthread_join() 来等待线程运行结束，并可得到线程的退出代码，回收其资源（类似于wait,waitpid)，但是调用 pthread_join(pthread_id)后，如果该线程没有运行结束，调用者会被阻塞，在有些情况下我们并不希望如此，比如在Web服务器中当主线程为每个新来的链接创建一个子线程进行处理的时候，主线程并不希望因为调用pthread_join而阻塞（因为还要继续处理之后到来的链接），这时可以在子线程中加入代码pthread_detach(pthread_self());或者父线程调用pthread_detach(thread_id)；这将该子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源。该函数接口为： 1234#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread);//note1：我们也可以在线程创建时就设置其属性为detached，如果设置一个线程为detached，就不能再调用pthread_join来等待获取其状态，这种情况返回值是不确定的。//note2： 线程与进程类似功能函数对比 2 线程的同步和互斥首先，我们来理一理互斥与同步的关系。 互斥互斥是指系统中的某些共享资源，一次只允许一个线程访问。当一个线程正在访问该临界资源时，其它线程必须等待。互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。互斥是一种特殊的同步。 实现互斥的手段有互斥锁(mutex)、读写锁(Reader_writer lock)、自旋锁(spin_lock)，实现同步需要用到条件变量（condition variable）** 2.1 互斥锁（Mutex）**通过锁机制实现线程间的互斥，保护临界资源。主要有以下接口函数：初始化锁—在Linux下，线程的互斥量数据类型是pthread_mutex_t。在使用前,要对它进行初始化。 1234//静态分配：pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//动态分配：int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutex_attr_t *mutexattr); 加锁—对共享资源的访问，要对互斥量进行加锁，如果互斥量已经上了锁，调用线程会阻塞，直到互斥量被解锁。如果不希望阻塞，可以使用pthread_mutex_trylock()，如果不能获得锁，立即返回EBUSY，二不会阻塞。 12int pthread_mutex_lock(pthread_mutex *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); 解锁—在完成了对共享资源的访问后，要对互斥量进行解锁。 1int pthread_mutex_unlock(pthread_mutex_t *mutex); 销毁锁锁在是使用完成后，需要进行销毁以释放资源。 1int pthread_mutex_destroy(pthread_mutex *mutex); 注意：要避免潜在的死锁危险，有多个互斥锁的情况下，各个线程加锁的顺序要相同。例程： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;int a = 200;int b = 100;pthread_mutex_t lock; void* ThreadA(void*)&#123; pthread_mutex_lock(&amp;lock); //锁 a -= 50; sleep(5); //执行到一半 使用sleep 放弃cpu调度 b += 50; pthread_mutex_unlock(&amp;lock);&#125; void* ThreadB(void*)&#123; sleep(1); //放弃CPU调度 目的先让A线程运行。 pthread_mutex_lock(&amp;lock); printf(\"%d\\n\", a + b); pthread_mutex_unlock(&amp;lock);&#125; int main()&#123; pthread_t tida, tidb; pthread_mutex_init(&amp;lock, NULL); pthread_create(&amp;tida, NULL, ThreadA, NULL); pthread_create(&amp;tidb, NULL, ThreadB, NULL); pthread_join(tida, NULL); pthread_join(tidb, NULL); return 0;&#125; 以上输出为300 去掉锁操作 输出为250。此例程为了说明互斥锁功能，正常使用试临界资源中不宜采用sleep这样的操作。** 2.2 读写锁 **读写锁跟互斥锁类似，只是在并发性上更加精细。互斥锁的状态要么加锁，要么未加锁，同一时刻只有一个线程可以获得锁。读写锁有三种状态： 读加锁状态 写加锁状态 未加锁状态如果一个读写锁在写加锁状态，所有试图加锁的线程在该读写锁释放前都会block。如果在读加锁状态，那么所有试图以读模式加锁的线程都将成功，但是如果要以写模式加锁，必须等到所有的加锁线程释放锁，这种情况下，以读模式加锁的线程也将阻塞。读写锁适合在经常读而不经常写的场景下使用。123456789101112131415#include &lt;pthread.h&gt;#include &lt;time.h&gt;int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr);int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr); //BOTH: return 0 if OK, error number on failure ** 2.3 自旋锁（spin lock）**关于自旋锁，APUE中的介绍感觉很到位，就不翻译了： A spin lock is like a mutex, except that instead of blocking a process by sleeping, the process is blocked by busy-waiting (spinning) until the lock can be acquired. A spin lock could be used in situations where locks are held for short periods of times and threads don’t want to incur the cost of being descheduled.鉴于spin lock忙等的特性，spin lock用于底层实时要求高的场景，且所锁定的临界区域尽量小，持锁时间尽量小。用户态，除非是早非抢占式实时操作系统上，否则没有使用的必要。spin lock的使用方式跟mutex类似，此处不再举例。 123456#include &lt;pthread.h&gt;int pthread_spin_init(pthread_spinlock_t *lock, int pshared);int pthread_spin_destroy(pthread_spinlock_t *lock);int pthread_spin_lock(pthread_spinlock_t *lock);int pthread_spin_trylock(pthread_spinlock_t *lock);int pthread_spin_unlock(pthread_spinlock_t *lock); Caution： We need to be careful not to call any functions that might sleep while holding the spin lock. If we do, then we’ll waste CPU resources by extending the time other threads will spin if they try to acquire it.** 2.4 条件变量（cond）**与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。条件变量分为两部分: 条件和变量。条件本身是由互斥量保护的。线程在改变条件状态前先要锁住互斥量。条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。条件的检测是在互斥锁的保护下进行的。如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的互斥锁。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得互斥锁，重新评价条件。如果两进程共享可读写的内存，条件变量可以被用来实现这两进程间的线程同步。初始化条件变量： 123456789101112//静态态初始化，pthread_cond_t cond = PTHREAD_COND_INITIALIER;//动态初始化，int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);等待条件成立：释放锁,同时阻塞等待条件变量为真才行。timewait()设置等待时间,仍未signal,返回ETIMEOUT(加锁保证只有一个线程wait)int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);int pthread_cond_timewait(pthread_cond_t *cond,pthread_mutex *mutex,const timespec *abstime);激活条件变量：int pthread_cond_signal(pthread_cond_t *cond);int pthread_cond_broadcast(pthread_cond_t *cond); //解除所有线程的阻塞清除条件变量：无线程等待,否则返回EBUSYint pthread_cond_destroy(pthread_cond_t *cond); 应用示例：caution：在thread_cond_wait()之前,必须先lock相关联的mutex, 因为假如目标条件未满足,pthread_cond_wait()实际上会unlock该mutex, 然后block,在目标条件满足后再重新lock该mutex, 然后返回. 123456789101112131415161718192021222324252627282930313233#include &lt;pthread.h&gt;struct msg &#123;struct msg *m_next;/* ... more stuff here ... */&#125;;struct msg *workq;pthread_cond_t qready = PTHREAD_COND_INITIALIZER;pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER;void process_msg(void)&#123; struct msg *mp; for (;;) &#123; //先要加锁，因为 pthread_cond_wait（）内部，如果条件不满足，则会释放锁，然后block pthread_mutex_lock(&amp;qlock); while (workq == NULL) pthread_cond_wait(&amp;qready, &amp;qlock); mp = workq; workq = mp-&gt;m_next; pthread_mutex_unlock(&amp;qlock); /* now process the message mp */ &#125;&#125;void enqueue_msg(struct msg *mp)&#123; pthread_mutex_lock(&amp;qlock); mp-&gt;m_next = workq; workq = mp; pthread_mutex_unlock(&amp;qlock); pthread_cond_signal(&amp;qready);&#125; 练习题：/*** 多线程联系： 编写一个程序，开启3个线程，这3个线程的ID分别为Ａ、Ｂ、Ｃ， 每个线程将自己的ID在屏幕上打印10遍，要求输出结果必须按ABC的顺序显示；如： ABCABC…依次递推* **/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;pthread_cond_t cond_a2b = PTHREAD_COND_INITIALIZER;pthread_cond_t cond_b2c = PTHREAD_COND_INITIALIZER;pthread_cond_t cond_c2a = PTHREAD_COND_INITIALIZER;pthread_mutex_t flag_lock = PTHREAD_MUTEX_INITIALIZER;int flag = 1;void *tida_func(void *arg)&#123; pthread_mutex_lock(&amp;flag_lock); for(;;) &#123; while(flag != 1) &#123; pthread_cond_wait( &amp;cond_c2a, &amp;flag_lock); &#125; flag += 1; printf(\"a\"); pthread_mutex_unlock(&amp;flag_lock); pthread_cond_signal(&amp;cond_a2b); &#125;&#125;void *tidb_func(void *arg)&#123; pthread_mutex_lock(&amp;flag_lock); for(;;) &#123; while(flag != 2) &#123; pthread_cond_wait(&amp;cond_a2b, &amp;flag_lock); &#125; flag += 1; printf(\"b\"); pthread_mutex_unlock(&amp;flag_lock); pthread_cond_signal(&amp;cond_b2c); &#125;&#125;int main()&#123; int count = 0; int iret = 0; pthread_t tida,tidb; iret = pthread_create(&amp;tida, NULL, tida_func, NULL); if( iret != 0) &#123; perror(\"pthread_create\"); return -1; &#125; iret = pthread_create(&amp;tidb, NULL, tidb_func, NULL); if(iret != 0) &#123; perror(\"pthread_create\"); return -1; &#125; while(count &lt; 10) &#123; pthread_mutex_lock(&amp;flag_lock); while(flag != 3) &#123; pthread_cond_wait(&amp;cond_b2c,&amp;flag_lock); &#125; printf(\"c \"); flag = 1; count++; pthread_mutex_unlock(&amp;flag_lock); pthread_cond_signal(&amp;cond_c2a); &#125; printf(\"\\n\"); return 0;&#125; 2.3 信号量(sem) —- 待完善如同进程一样，线程也可以通过信号量来实现通信，虽然是轻量级的。信号量函数的名字都以”sem_”打头。线程使用的基本信号量函数有四个。信号量初始化： int sem_init (sem_t *sem , int pshared, unsigned int value);这是对由sem指定的信号量进行初始化，设置好它的共享选项(linux 只支持为0，即表示它是当前进程的局部信号量)，然后给它一个初始值VALUE。等待信号量：给信号量减1，然后等待直到信号量的值大于0。 int sem_wait(sem_t *sem);释放信号量：信号量值加1。并通知其他等待线程。 int sem_post(sem_t *sem);销毁信号量：我们用完信号量后都它进行清理。归还占有的一切资源。 int sem_destroy(sem_t *sem); 单纯互斥：用互斥锁既要同步又要互斥：条件变量和互斥所结合使用 note单纯同步：用信号量 3 线程相关的属性3.1 线程的属性 在前面的例程中，我们在创建线程时，线程属性参数都传入了NULL，取了默认的属性。线程的属性由 pthread_attr_t 结构定义。 12345678910111213//线程属性结构如下： typedef struct &#123; int detachstate; //线程的分离状态 int schedpolicy; //线程调度策略 structsched_param schedparam; //线程的调度参数 int inheritsched; //线程的继承性 int scope; //线程的作用域 size_t guardsize; //线程栈末尾的警戒缓冲区大小 int stackaddr_set; //线程的栈设置 void* stackaddr; //线程栈的位置 size_t stacksize; //线程栈的大小 &#125;pthread_attr_t; 属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。之后须用pthread_attr_destroy函数来释放资源。线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省1M的堆栈、与父进程同样级别的优先级。 每个属性都有其函数接口设置或获取，在此不一一列举，下面示例为创建一个detached 线程： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;int makethread(void *(*fn)(void *), void *arg)&#123; int err; pthread_t tid; pthread_attr_t attr; err = pthread_attr_init(&amp;attr); if (err != 0) return(err); err = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); if (err == 0) err = pthread_create(&amp;tid, &amp;attr, fn, arg); pthread_attr_destroy(&amp;attr); return(err);&#125; 3.2 互斥锁属性、读写锁属性、条件变量属性 –待完善 互斥所属性：process-shared attributerobust attributetype attribute读写锁属性process-shared attribute条件变量属性：process-shared attributeclock attribute","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}]},{"title":"ubuntu18.04国内软件源","slug":"ubuntu18-04国内软件源","date":"2019-10-12T09:47:16.000Z","updated":"2019-10-12T14:57:57.609Z","comments":true,"path":"2019/10/12/ubuntu18-04国内软件源/","link":"","permalink":"http://yoursite.com/2019/10/12/ubuntu18-04国内软件源/","excerpt":"ubuntu默认的软件源是国外的，下载软件很慢，需要更新为国内的源以提升速度，现在可以通过ubunt software来设置了，不过还是习惯了命令行修改的方式。更新方法123sudo vi /etc/apt/sources.list#替换内容为国内源码sudo apt update","text":"ubuntu默认的软件源是国外的，下载软件很慢，需要更新为国内的源以提升速度，现在可以通过ubunt software来设置了，不过还是习惯了命令行修改的方式。更新方法123sudo vi /etc/apt/sources.list#替换内容为国内源码sudo apt update 国内源国内有很多Ubuntu的镜像源,如下 中科大源 deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 阿里源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 163源 deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse 清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://yoursite.com/categories/开发环境/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}]},{"title":"PDF-XChange Viewer 设置背景颜色","slug":"PDF-XChange-Viewer-设置背景颜色","date":"2019-10-12T09:09:48.000Z","updated":"2019-10-12T14:57:57.606Z","comments":true,"path":"2019/10/12/PDF-XChange-Viewer-设置背景颜色/","link":"","permalink":"http://yoursite.com/2019/10/12/PDF-XChange-Viewer-设置背景颜色/","excerpt":"日常阅读Pdf文档书籍比较多，白色的背景会比较刺眼，传言淡绿色的会比较护眼（真假不知）。PDF-XChange Viewer 这款软件在阅读pdf时体验非常好，打开大文件相应也很快，具有完善的注释功能。本人在设置背景颜色时颇为曲折，书签栏的背景颜色始终难以设置成功，经过多次实验发现了最方便的设置如下位置：编辑 -&gt; 参数设置 -&gt; 自定义UI -&gt; 颜色","text":"日常阅读Pdf文档书籍比较多，白色的背景会比较刺眼，传言淡绿色的会比较护眼（真假不知）。PDF-XChange Viewer 这款软件在阅读pdf时体验非常好，打开大文件相应也很快，具有完善的注释功能。本人在设置背景颜色时颇为曲折，书签栏的背景颜色始终难以设置成功，经过多次实验发现了最方便的设置如下位置：编辑 -&gt; 参数设置 -&gt; 自定义UI -&gt; 颜色","categories":[{"name":"开发环境","slug":"开发环境","permalink":"http://yoursite.com/categories/开发环境/"}],"tags":[{"name":"开发环境","slug":"开发环境","permalink":"http://yoursite.com/tags/开发环境/"}]},{"title":"Linux 下 Samba 服务器配置samb目录为用户的home目录","slug":"samba服务器配置","date":"2019-10-10T13:44:10.404Z","updated":"2019-10-10T13:44:10.404Z","comments":true,"path":"2019/10/10/samba服务器配置/","link":"","permalink":"http://yoursite.com/2019/10/10/samba服务器配置/","excerpt":"在多用户的使用场景下，为了统一为各个用户配置samba目录，可以将用户的home目录统一配置成samba目录，下面以在ubuntu上配置为例进行说明。1.先要安装Samba1sudo apt-get install samba openssh-server","text":"在多用户的使用场景下，为了统一为各个用户配置samba目录，可以将用户的home目录统一配置成samba目录，下面以在ubuntu上配置为例进行说明。1.先要安装Samba1sudo apt-get install samba openssh-server 2.编译Samba配置文件1sudo vi /etc/samba/smb.conf 找到[homes]项，此项默认是注释掉的，取消其注释，然后修改其具体内容，修改成如下： 12345678910111213141516171819[homes] comment = Home Directories browseable = yes# By default, the home directories are exported read-only. Change the# next parameter to 'no' if you want to be able to write to them. read only = no# File creation mask is set to 0700 for security reasons. If you want to# create files with group=rw permissions, set next parameter to 0775. create mask = 0755 #建议将权限修改成0755，这样其它用户只是不能修改# Directory creation mask is set to 0700 for security reasons. If you want to# create dirs. with group=rw permissions, set next parameter to 0775. directory mask = 0755# By default, \\\\server\\username shares can be connected to by anyone# with access to the samba server. Un-comment the following parameter# to make sure that only \"username\" can connect to \\\\server\\username# The following parameter makes sure that only \"username\" can connect## This might need tweaking when using external authentication schemes valid users = %S #本行需要取消注释 如上修改完成后wq保存退出！ 3. 重启samba服务：12sudo service smbd restartsudo service nmbd restart 4. 增加一个现有用户的对应samba帐号：如我已经有一个用户叫dante，现在给dante开通samba帐号(必须设置)： 1sudo smbpasswd -a dante 根据提示输入两次密码即可。 5.现在可以测试了，在Window下按win+r，输入samba地址尝试登录：\\10.0.0.2\\dante 6.此时windows应该会弹出窗口要求输入用户名和密码了，输入吧。Enjoy！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"samba","slug":"samba","permalink":"http://yoursite.com/tags/samba/"}]},{"title":"Git 常用命令一览","slug":"Git常用命令一览","date":"2019-10-10T09:05:48.000Z","updated":"2019-10-10T13:44:10.403Z","comments":true,"path":"2019/10/10/Git常用命令一览/","link":"","permalink":"http://yoursite.com/2019/10/10/Git常用命令一览/","excerpt":"git配置（config）：12345678git version # 查看版本git config -l # 查看当前配置git config --global user.name \"Dean\" # 设置用户名，邮箱 git config --global user.email g.xiangyu1990@gmail.com # 设置用户名，邮箱 git config --global alias.ci commit # 设置git命令的别名git config --global alias.co checkout # 设置git命令的别名git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\"git config --global core.editor vim #设置编辑器为vim","text":"git配置（config）：12345678git version # 查看版本git config -l # 查看当前配置git config --global user.name \"Dean\" # 设置用户名，邮箱 git config --global user.email g.xiangyu1990@gmail.com # 设置用户名，邮箱 git config --global alias.ci commit # 设置git命令的别名git config --global alias.co checkout # 设置git命令的别名git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\"git config --global core.editor vim #设置编辑器为vim git仓库（repository）：12345# 创建一个本地的git仓库并命名： git init demo​# 克隆一个远程的git仓库到指定路径： git clone https://github.com/a396901990/android.git /path/workpsace git分支（branch）:1234567git branch # 查看分支git remote show origin # 查看所有分支git branch &lt;branchname&gt; # 创建新分支git checkout &lt;branchname&gt; # 切换到分支git checkout -b &lt;new_branch&gt; # 创建并切换到新分支git branch -d &lt;branchname&gt; # 删除分支（-D强删） git branch -m &lt;old&gt; &lt;new&gt; # 本地分支重命名 git添加（add）：12345git add &lt;file&gt; # 将本地指定文件名或目录（新增和修改，没有删除）的文件添加到暂存区git add . # 将本地所有的（新增和修改，没有删除）文件添加到暂存区git add -u # 将本地的（修改和删除，没有新增）文件添加到暂存区git add -A # 将本地所有改动添加到暂存区（git add -A = git add . + git add -u）git add -i # 打开一个交互式界面按需求添加文件 git删除/重命名（rm/mv）：1234git rm &lt;file&gt; # 删除文件git rm -r &lt;floder&gt; # 删除文件夹git rm --cached &lt;file&gt; # 从版本库中删除文件，但不删除文件 git mv &lt;old_name&gt; &lt;new_name&gt; # 文件重命名 git提交（commit）：1234git commit -m \"comment\" # 提交暂存区中的内容（已经add）并添加注释git commit -a # 把修改的文件添加到暂存区（不包括新建(untracked)的文件），然后提交。git commit --amend # 修改提交的commit（没有push）git commit --amend -m \"comment\" # 修改commit注解 git差异（diff）：123456git diff # 查看工作目录（working tree）暂存区（index）的差别git diff --cached # 查看暂存起来的文件（stage）与并未提交（commit）的差别git diff --staged # 同上git diff HEAD # 查看最后一次提交之后的的差别（HEAD代表最近一次commit的信息）git diff --stat # 查看显示简略结果(文件列表)git diff commit1 commit2 # 对比两次提交的内容（也可以是branch，哈希值） git查看历史（log）：123456git loggit log -3 # 查看前3次修改git log --oneline # 一行显示一条loggit log -p # 查看详细修改内容 git log --stat # 查看提交统计信息git log --graph # 显示何时出现了分支和合并等信息 git查看状态（status）：123git status # 查看你的代码在缓存与当前工作目录的状态git status -s # 将结果以简短的形式输出git status --ignored # 显示被忽略的文件 git存储（stash）:1234567git stash # 保存当前的工作进度git stash save \"message\" # 保存进度加说明git stash list # 显示进度列表git stash pop # 恢复最新保存的工作进度，并将恢复的工作进度从存储的列表中删除git stash apply # 恢复最新保存工作进度，但不删除git stash drop # 删除一个进度，默认删除最新的git stash clear # 删除所有 git重置（reset）:12345678git reset --mixed # 同不带任何参数的git reset一样，重置暂存区，但不改变工作区git reset --soft # 回退到某个版本，不改变暂存区和工作区（如果还要提交，直接commit即可）git reset --hard # 彻底回退到某个版本，替换暂存区和工作区，本地的源码也会变为上一个版本的内容git reset # 将之前用git add命令添加到暂存区的内容撤出暂存区（相当于git add -A 的反向操作）git reset HEAD # HEAD 效果同上，因为引用重置到HEAD相当与没有重置git reset filename # 将文件撤出暂存区（相当于git add filename的反向操作）git reset HEAD^ # 引用回退一次（工作区不变，暂存区回退）git reset --soft HEAD~3 # 引用回退三次（工作区不变，暂存区不变） git撤销（revert）：1234git revert commit # 撤销指定commitgit revert HEAD # 撤销上一次commitgit revert -no-edit HEAD # 撤销上一次并直接使用默认注释git revert -n HEAD # 撤销上一次但不commit git合并（merge）：123git merge &lt;branch_name&gt; # 合并git merge --no-ff &lt;branch_name&gt; # 采用no fast forward的合并方式，这种方式在合并的同时会生成一个新的commitgit merge --abort # 尽量回退到merge前的状态（可能会失败） git重新基变（rebase）：1234git rebase &lt;branch_name&gt; # git rebase --continue # 执行rebase出现冲突解决后，执行该命令会继续应用(apply)余下的补丁git rebase --skip # 跳过当前提交git rebase --abort # 终止rebase, 分支会回到rebase开始前的状态 git获取/拉（fetch/pull）：123git fetch # 从远程获取最新版本到本地，不会自动mergegit pull # 从远程获取最新版本并merge到本地git pull --rebase # 暂存本地变更，合并远程最新改动，合并刚刚暂存的本地变更（不产生无用的merge的同步） git推（push）:12345git push origin master # 将本地分支推送到origin主机的master分支git push -u origin master # -u指定origin为默认主机，后面就可以不加任何参数使用git push了git push -f origin # -f强推，在远程主机产生一个\"非直进式\"的合并(non-fast-forward merge)git push --all origin # 将所有本地分支都推送到origin主git push origin &lt;本地分支&gt;：&lt;远程分支&gt; #个人目前常用","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"git设置ssh-key免输密码","slug":"git设置ssh-key免输密码","date":"2019-10-10T09:05:48.000Z","updated":"2019-10-10T13:44:10.404Z","comments":true,"path":"2019/10/10/git设置ssh-key免输密码/","link":"","permalink":"http://yoursite.com/2019/10/10/git设置ssh-key免输密码/","excerpt":"当我们从github或者gitlab上clone项目或者参与项目时，我们需要证明我们的身份。一种可能的解决方法是我们在每次访问的时候都带上账户名、密码,另外一种办法是在本地保存一个唯一key，在你的账户中也保存一份该key，在你访问时带上你的key即可。github、gitlab就是采用key来验证你的身份的，并且利用RSA算法来生成这个密钥。","text":"当我们从github或者gitlab上clone项目或者参与项目时，我们需要证明我们的身份。一种可能的解决方法是我们在每次访问的时候都带上账户名、密码,另外一种办法是在本地保存一个唯一key，在你的账户中也保存一份该key，在你访问时带上你的key即可。github、gitlab就是采用key来验证你的身份的，并且利用RSA算法来生成这个密钥。 1.生成SSH密钥 1ssh-keygen -t rsa -C \"mail@gmail.com\" 执行后，第一个提示输入保存文件名，默认为空，回车。 第二个提示输入密钥，默认为空，回车 第三个确认刚输入密钥，默认为空，回车 完成后，默认保存在当前 用户的home目录下 ~/.ssh/id_rsa 和id_rsa.pub 1cd ~/.ssh #可以看到生成的文件 2.设置密钥（gitlab/gitblit都有试过，其他未测） 在 Gitblit 管理页面，把 id_rsa.pub 中的内容复制到 SSH Keys，保存确定。 3.clone 克隆 （或其他操作） 设置成功，git clone/push/pull无须再输入密码 1git clone ssh://test@192.168.0.254:29418/test.git","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]}]}